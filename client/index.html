<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <title>Document</title>
  </head>
  <body>
    <div class="wrapper">
      <h1>WebSockets Echo Demo</h1>
      <button type="submit" id="open_ws">Open WS</button>
      <div id="status" class="status">Status: Not connected</div>
      <div id="server_response"></div>
      <ul id="table"></ul>
      <form id="form" class="form">
        <textarea
          name="message"
          id="message"
          placeholder="Write your message here..."
          required
        ></textarea>
        <button type="submit">Send Message</button>
        <button id="close_ws" type="button">Close Connection</button>
        <button type="button" id="populate" class="populate">Populate</button>
      </form>
    </div>
    <script>
      const openWsBtn = document.getElementById("open_ws");
      const closeWsBtn = document.getElementById("close_ws");
      const form = document.getElementById("form");
      const socketStatus = document.getElementById("status");
      const serverResponse = document.getElementById("server_response");
      const table = document.getElementsByTagName("ul")[0];
      const message = document.getElementById("message");

      // テスト用
      const populateBtn = document.getElementById("populate");

      openWsBtn.addEventListener("click", () => {
        // 一回しかクリックできないようにするだけのコード
        openWsBtn.disabled = true;
        openWsBtn.style.background = "gray";
        openWsBtn.style.pointerEvents = "none";
        openWsBtn.textContent = "Button disabled";

        // websocketサーバーと接続開始
        // const url = "ws://127.0.0.1:8080"; // v2動作時
        const url = "wss://127.0.0.1:4430";
        const socket = new WebSocket(url);

        // WebSocketAPIで利用できるメソッドは二種類しかないシンプル設計
        // send()とclose()
        // sendはWebSocket接続を通じてデータを送信するために使う
        // closeはクローズハンドシェイクを開始して、WebSocket接続を終了するために使う
        console.log({ socket });

        // 0:CONNECTING WebSocket接続を開始した直後、まだ確立されていない接続
        // 1:OPEN 接続が開かれ、通信できる状態
        // 2:CLOSING 接続を閉じる処理中
        // 3;CLOSED 接続が完全に閉じられた状態
        console.log(`SOCKET CONNECTING STATUS IS: ${socket.readyState}`); // ここでは0が表示される

        socketStatus.innerHTML = "Connecting ...";

        // OPEN
        socket.onopen = (openEvent) => {
          console.log(`SOCKET CONNECTING STATUS IS: ${socket.readyState}`);
          socketStatus.innerHTML = `Connected to: ${openEvent.currentTarget.url}`;
          socketStatus.className = socketStatus.className + " open";
          form.className = "show_form";
          table.innerHTML = "";
          serverResponse.innerHTML = "";
          console.log({ openEvent });

          // テスト用
          // 例；5000バイト（中規模）,150000(大規模)
          const text = "A".repeat(150000);
          populateBtn.addEventListener("click", () => {
            message.value = text;
          });
        };

        // RECEIVE
        socket.onmessage = (messageEvent) => {
          // クライアントがサーバーからメッセージを受け取った場合に発火する
          // プロパティ data: 文字列、Blob、ArrayBufferのいずれか origin:メッセージ送信元
          if (messageEvent.data instanceof Blob) {
            const reader = new FileReader();
            reader.readAsText(messageEvent.data);
            reader.onload = function (e) {
              const msg = e.target.result;
              table.innerHTML += "<li><span>Received:</span>" + msg + "</li>";
              message.placeholder = `(Previous message size: ${msg.length})`;
            };
          } else {
            const msg = messageEvent.data;
            table.innerHTML += "<li><span>Received:</span>" + msg + "</li>";
            message.placeholder = `(Previous message size: ${msg.length})`;
          }
        };

        // CLOSE
        socket.onclose = (closeEvent) => {
          console.log(`SOCKET CONNECTING STATUS IS: ${socket.readyState}`); // 3
          // クライアント・サーバーのどちらから接続を閉じても必ず発火する
          // クラアントが「Closeフレーム」を送信・受信した後に発火する
          console.log({ closeEvent });
          // 便利なプロパティ code: 接続を閉じた側が設定する終了コード reason: 接続が閉じた理由(セキュリティ上の理由で最大123文字制限あり) wasClean: true、両者がCloseクレームを交換した場合（正常終了）false、異常終了
          console.log(closeEvent.code, closeEvent.reason, closeEvent.wasClean);

          form.className = "form closed";

          switch (closeEvent.code) {
            case 1001:
              socketStatus.innerHTML = `Disconnected: ${closeEvent.reason}`;
              table.innerHTML = "";
              break;
            case 1002:
              socketStatus.innerHTML = `Disconnected: ${closeEvent.reason}`;
              table.innerHTML = "";
              serverResponse.innerHTML = `The server responded: ${closeEvent.reason}`;
              break;
            case 1003:
              socketStatus.innerHTML = `Unsupported data type.`;
              table.innerHTML = "";
              serverResponse.innerHTML = `The server responded: ${closeEvent.reason}`;
              break;
            case 1006:
              // サーバーへ接続失敗
              socketStatus.innerHTML = "No go my friend";
              table.innerHTML +=
                '<li class="received, closed"><span>ERROR:</span>' +
                "Something is wrong with your connection" +
                "</li>";
              break;
            case 1008:
              socketStatus.innerHTML = `You violated server policy.`;
              table.innerHTML = "";
              serverResponse.innerHTML = `The server responded: ${closeEvent.reason}`;
              break;
            case 1009:
              socketStatus.innerHTML = `Data too long.`;
              table.innerHTML = "";
              serverResponse.innerHTML = `The server responded: ${closeEvent.reason}`;
              break;

            default:
              socketStatus.innerHTML = "You disconnected from WebSockets.";
              table.innerHTML +=
                '<li class="received, closed"><span>CLOSED:</span>' +
                "YOU CLOSED THE CONNECTION" +
                "</li>";
              serverResponse.innerHTML = `The server responded: ${closeEvent.reason}`;
              break;
          }

          // ボタンの活性化
          openWsBtn.disabled = false;
          openWsBtn.style.background = "";
          openWsBtn.style.pointerEvents = "";
          openWsBtn.textContent = "Open WS";
        };

        // ERROR
        socket.onerror = (error) => {
          // WebSocket接続でなんらかの問題が発生した際に発火する
          // 多くの場合、onerrorの直後にoncloseイベントも発火する
          // onopenイベントによって提供されるオブジェクトと同じ型
          // typeがerror
          // 実際、そこまでエラーについての情報は提供されないことが多く、oncloseを見た方が有用
          // 発生例:
          // - WebSocketハンドシェイク中のエラー
          //   - 例:不正なHTTPヘッダー、プロトコルの不一致など
          //   - onopenイベントが発火する前にonerrorが発火する
          // - ネットワークエラー
          //   - 例:クライアントがインターネット接続を失う
          //   - onerrorイベントの後にoncloseイベントが発火する
          // - サーバーからエラーフレームが送信された場合
          //   - サーバーがエラーコード付きの特別なWebSocketフレームを送信すると、クライアント側でonerrorが発火する
          // - サーバーが突然接続終了した場合
          //   - サーバーが正規のCloseフレームを送信せずに接続を切ると、onerrorのみが発火する
          // - クライアントライブラリやブラウザ内部エラー
          //   - onerrorが発火
          // closeイベントから返されるエラー情報も曖昧な内容となっている。理由はセキュリティ上あえてそういう設計になっているため。
          // https://websockets.spec.whatwg.org/#feedback-from-the-protocol

          console.log(error);
          socket.innerHTML = "Error.";
          form.className = "closed";
        };

        // CLOSE METHOD
        closeWsBtn.addEventListener("click", () => {
          // socket.close();
          // サーバー側に理由を送ることも可能
          // クライアントから閉じるときはステータスコードが必須
          socket.close(1000, "I don't like you");

          console.log(`SOCKET CONNECTING STATUS IS: ${socket.readyState}`); // 2

          // form.className = "";
          openWsBtn.disabled = false;
          openWsBtn.style.background = "";
          openWsBtn.style.pointerEvents = "";
          openWsBtn.textContent = "Open WS";
        });

        // SEND METHOD
        form.addEventListener("submit", (e) => {
          e.preventDefault();
          // すでに閉じられた可能性のある古いソケットでの送信をしないようにする
          if (socket.readyState === 1) {
            const userText = message.value;
            socket.send(userText);

            table.innerHTML +=
              '<li class="sent"><span>SENT:</span>' + userText + "</li>";
            message.value = "";
          }
        });
      });
    </script>
  </body>
</html>
